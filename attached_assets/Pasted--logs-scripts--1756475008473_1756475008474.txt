بعد ان  قرأت الـlogs والـscripts بعناية وطلعت على النقاط الحرجة. أدرج أدناه تشخيص مُركَّز للأسباب الحقيقية للمشكلة ("الطبقات لا تظهر على الخريطة رغم المعالجة")، ثم خطوات إصلاح عملية مع كود جاهز للحقن في المشروع (server + client) وطرق اختبار سريعة.

ملخّص المشكلة (باختصار)
- النظام صار يعالج ملفات ZIP/GeoTIFF وينتج PNG — والـPNG موجود على القرص. لكن:
  1) التنسيق/مفتاح الميتاداتا غير موحَّد بين معالجات Python المختلفة (بعضها يطبع result.bounds، بعضها يطبع bounds_wgs84 أو png_file أو output_image). هذا يجعل كود الـNode يواجه حالات مختلفة أو لا يجد اسم الصورة أو الـbounds الصحيحة.  
  2) تخزين حالة الطبقات في Map بالذاكرة (layerStates) فقط → اختفاء الطبقات عند إعادة تشغيل السيرفر.  
  3) تنسيقات الـbounds غير موحَّدة (bbox [w,s,e,n] vs leaflet [[s,w],[n,e]] vs [[lat,lon],[lat,lon]] ) — الواجهة تستخدم صيغة واحدة بينما المعالج يعطي أخرى → الصورة تُوضع في مكان خاطئ أو خارج العرض.  
  4) بعض أجزاء الكود تعتمد على إخراج stdout من Python بصيغة محددة (مثلاً يبحث عن "SUCCESS:" أو يحاول عمل JSON كامل من stdout المختلط) — طُرق هشة.  
- النتيجة: الصورة موجودة في filesystem، لكن الـclient يحصل على معلومات غير صحيحة أو لا يستطيع تحديد bounds الصحيحة أو الصورة بسبب أسماء مختلفة، لذلك لا تظهر جغرافياً.

الأهداف المطلوبة لإصلاح مستدام
1. توحيد مخرجات المعالجات: كل معالج Python يجب أن يكتب ملف metadata.json داخل مجلد الطبقة ويحوي حقول موحدة.  
2. جعل Node لا يعتمد على stdout فقط، بل يقرَأ metadata.json من outputDir ليبني layerStates.  
3. عند بدء السيرفر، استرجاع الطبقات من temp-uploads/processed وملء layerStates (الاستمرارية بعد إعادة تشغيل السيرفر).  
4. توحيد صيغة الحدود: احفظ كلًا من bbox ([west,south,east,north]) و leaflet_bounds ([[south,west],[north,east]]) في metadata.json.  
5. في الـclient: إضافة تحويل robust لأي صيغة bounds إلى صيغة Leaflet، وتعيين crossOrigin + fitBounds.  
6. تحسين الـlogging وواجهات الخطأ لسهولة تتبُّع لماذا صورة لا تُحمّل أو تُعرض.

الخطوات العملية (كود جاهز وملخص تنفيذ)

A) معيار مخرجات المعالج (Python)
ضع عند نهاية كل معالج (zip-processor.py و enhanced-geotiff-processor.py) كتابة metadata.json موحّد، مثال (واضح ومباشر — أضفه بعد حفظ الصورة):

```python
# بعد حفظ processed.png وحساب final_bounds = [west, south, east, north]
metadata = {
  "success": True,
  "imageFile": os.path.basename(output_image_path),      # e.g. "processed.png"
  "bbox": [final_bounds[0], final_bounds[1], final_bounds[2], final_bounds[3]],  # [west, south, east, north]
  "leaflet_bounds": [[final_bounds[1], final_bounds[0]], [final_bounds[3], final_bounds[2]]],  # [[south,west],[north,east]]
  "width": width,
  "height": height,
  "crs": "EPSG:4326",
  "original_name": original_name or os.path.basename(input_file)
}
with open(os.path.join(output_dir, 'metadata.json'), 'w', encoding='utf-8') as f:
    json.dump(metadata, f, ensure_ascii=False, indent=2)
# وأيضًا اطبع النتيجة النهائية كـJSON للخلفية إن رغبت:
print(json.dumps(metadata, ensure_ascii=False))
```

ملاحظات:
- احرص أن يكون final_bounds = [west, south, east, north] قبل إنشاء leaflet_bounds كما في الأعلى.
- بهذه الطريقة يصبح هناك معيار واحد يمكن للـNode الاعتماد عليه.

B) تعديل Node (server) — قراءة metadata.json بدل الاعتماد على stdout (أسهل وأكثر موثوقية)
أدرج هذه الدوال في server/routes/enhanced-upload.ts (أو في موديل خدماتك):

```ts
import fs from 'fs/promises';
import path from 'path';

async function readLayerMetadata(outputDir: string) {
  const metaPath = path.join(outputDir, 'metadata.json');
  try {
    const raw = await fs.readFile(metaPath, 'utf8');
    const meta = JSON.parse(raw);
    return meta;
  } catch (e) {
    // fallback: find first PNG in folder
    try {
      const files = await fs.readdir(outputDir);
      const png = files.find(f => f.toLowerCase().endsWith('.png'));
      if (!png) throw new Error('metadata.json not found and no png in outputDir');
      return {
        success: true,
        imageFile: png,
        leaflet_bounds: null,
        bbox: null
      };
    } catch (err) {
      throw err;
    }
  }
}

function bboxToLeafletBounds(bbox: number[]) {
  // bbox = [west, south, east, north]
  const [w,s,e,n] = bbox;
  return [[s,w],[n,e]];
}

async function finalizeLayerStateFromOutput(layerId: string, outputDir: string, originalName?: string, fileSize?: number) {
  try {
    const meta = await readLayerMetadata(outputDir);
    // find image filename
    const imageFile = meta.imageFile || (await (async () => {
      const files = await fs.readdir(outputDir);
      return files.find(f => f.toLowerCase().endsWith('.png')) || null;
    })());

    if (!imageFile) throw new Error('No image file produced');

    // unify leafletBounds
    let leafletBounds = meta.leaflet_bounds || null;
    if (!leafletBounds && meta.bbox && meta.bbox.length === 4) {
      leafletBounds = bboxToLeafletBounds(meta.bbox);
    } else if (!leafletBounds && meta.bounds && Array.isArray(meta.bounds) && meta.bounds.length === 2) {
      leafletBounds = meta.bounds; // assume already [[s,w],[n,e]] or [[lat,lon],[lat,lon]]
    } else if (!leafletBounds) {
      // fallback: whole Yemen (or null & mark un-georeferenced)
      leafletBounds = [[12.0, 42.0], [19.0, 54.0]];
    }

    const imageUrl = `/api/gis/layers/${layerId}/image/${imageFile}`;

    layerStates.set(layerId, {
      status: 'processed',
      fileName: originalName || meta.original_name || layerId,
      fileSize: fileSize || meta.width || 0,
      uploadDate: new Date().toISOString(),
      imageUrl,
      bounds: leafletBounds,
      width: meta.width,
      height: meta.height,
      crs: meta.crs || 'EPSG:4326'
    });

    // persist a simple copy of state (optional)
    await fs.writeFile(path.join(outputDir, 'layer-state.json'), JSON.stringify({
      id: layerId,
      imageFile,
      leaflet_bounds: leafletBounds,
      bbox: meta.bbox || null,
      crs: meta.crs || null
    }, null, 2), 'utf8');

    console.log(`✅ layer ${layerId} finalized: image=${imageFile}`);
  } catch (err) {
    console.error('❌ finalizeLayerStateFromOutput error:', err);
    layerStates.set(layerId, {
      status: 'error',
      fileName: originalName || layerId,
      fileSize: fileSize || 0,
      uploadDate: new Date().toISOString(),
      error: err instanceof Error ? err.message : String(err)
    });
  }
}
```

- عدّل نقطة استدعاء Python (spawn/exec) لتقوم فقط بتشغيل المعالج، ثم على close/then تشغل finalizeLayerStateFromOutput(layerId, outputDir, originalName, fileSize). لا تعتمد على stdout مقامسنتًا.

C) استرجاع الطبقات عند بدء السيرفر (حل المشكلة: النسخ في الذاكرة تضيع بعد restart)
ضع دالة تُشغَّل عند تشغيل السيرفر:

```ts
async function hydrateLayersFromDisk() {
  const processedRoot = path.join(process.cwd(), 'temp-uploads', 'processed');
  try {
    const entries = await fs.readdir(processedRoot, { withFileTypes: true });
    for (const e of entries) {
      if (!e.isDirectory()) continue;
      const layerId = e.name;
      const layerDir = path.join(processedRoot, layerId);
      try {
        // حاول قراءة layer-state.json أو metadata.json
        await finalizeLayerStateFromOutput(layerId, layerDir);
      } catch (err) {
        console.warn(`⚠️ failed to hydrate ${layerId}:`, err.message || err);
      }
    }
  } catch (e) {
    console.warn('No processed folder or cannot read processed folder', e.message || e);
  }
}
// استدعِ الدالة أثناء تهيئة السيرفر (قبل routes أو بعدهم لكن قبل استقبال طلبات)
hydrateLayersFromDisk();
```

D) Serve images: تأكد من headers CORS + Content-Type (يبدو أنك فعلت ذلك، لكن تأكد أنه يعمل في جميع المسارات)
مثال route لإرسال الصورة (أنت تستخدم sendFile، تأكد الـheader Access-Control-Allow-Origin موجود):

```ts
res.setHeader('Access-Control-Allow-Origin', '*'); // أو اضبط origin المناسب
res.setHeader('Cache-Control', 'public, max-age=3600');
res.sendFile(path.resolve(imagePath));
```

E) Client — تحويل أي صيغة bounds إلى Leaflet و إضافة overlay
أضِف دالة utility robust في client:

```js
// utils/geo.js
export function toLeafletBounds(raw, metaCrs = 'EPSG:4326') {
  if (!raw) return null;

  // bbox [west, south, east, north]
  if (Array.isArray(raw) && raw.length === 4 && typeof raw[0] === 'number') {
    const [w,s,e,n] = raw;
    return [[s,w],[n,e]];
  }

  // array-of-2-points [[a,b],[c,d]]
  if (Array.isArray(raw[0]) && Array.isArray(raw[1])) {
    const p1 = raw[0], p2 = raw[1]; // ambiguous
    // If metaCrs is EPSG:4326 assume [lat, lon] pairs (Leaflet style)
    if (metaCrs && metaCrs.includes('4326')) {
      return raw; // assume already [[south, west],[north, east]] or [[lat,lon],[lat,lon]]
    }
    // otherwise assume already correct (caller should prefer leaflet_bounds)
    return raw;
  }

  return null;
}
```

ثم عند إضافة الصورة لِـLeaflet:

```js
import L from 'leaflet';
import { toLeafletBounds } from './utils/geo';

function addLayerOverlay(map, layer) {
  const bounds = toLeafletBounds(layer.bounds || layer.leaflet_bounds || layer.bbox, layer.crs);
  if (!bounds) {
    console.error('Invalid bounds for layer', layer.id, layer.bounds);
    return;
  }
  console.log('Adding overlay', layer.imageUrl, 'bounds', bounds);
  // Preload image to detect errors early
  const img = new Image();
  img.crossOrigin = 'anonymous';
  img.onload = () => {
    L.imageOverlay(layer.imageUrl, bounds, { opacity: 1, crossOrigin: true }).addTo(map);
    try { map.fitBounds(bounds, { maxZoom: 17 }); } catch(e) { console.warn(e); }
  };
  img.onerror = (err) => {
    console.error('Image load failed:', layer.imageUrl, err);
  };
  img.src = layer.imageUrl;
}
```

F) إصلاحات سريعة/نُقَط مراجعة في كودك الحالي
- توحيد أسماء الحقول: استخدم imageFile / imageUrl / leaflet_bounds / bbox / crs / width / height. عدّل كل موضع في Node يقرأ نتيجة Python ليتوقع هذه الحقول.  
- تجنّب الاعتماد على parsing stdout المختلط — استعمل ملف metadata.json الموجود في مجلد الطبقة.  
- لا تعطي default Yemen bounds دائمًا: فقط استعملها كخيار أخير (مع وضع flag بأن الصورة غير جيو-مرجعة). وبيّن ذلك للمستخدم في الـUI (مثلاً badge "No georef — placed at default location").  
- ضع cors() middleware عند بداية السيرفر (قبل routes و static) لضمان عدم حظر الطلبات من المتصفح (خصوصاً عند Replit).

G) اختبارات سريعة تُجريها الآن (أوامر)
1) تأكد أن الـPNG يُقدّم:
   - curl -I "http://localhost:5000/api/gis/layers/<layerId>/image/<imageFile>.png"
     -> Status: 200 و Content-Type: image/png و Access-Control-Allow-Origin: *
2) تحقق metadata:
   - cat temp-uploads/processed/<layerId>/metadata.json
     -> تأكد وجود leaflet_bounds و bbox و imageFile
3) JSON layer endpoint:
   - curl -s "http://localhost:5000/api/gis/layers/<layerId>" | jq .
     -> تأكد النتيجة تحتوي imageUrl و bounds (في صيغة leaflet)
4) في المتصفح: افتح Network وConsole، أعد تحميل الخريطة، راقب تحميل الصورة (status 200 أو 404) ورسائل CORS.

H) حل مشكلة فقدان الطبقات عند إعادة التشغيل (مقترح طويل الأمد)
- إما: احفظ metadata (كما في خطوةB) لكل طبقة داخل temp-uploads/processed/<layerId>/metadata.json (هذا كافٍ لإعادة الإنشاء عند التشغيل).  
- أو: استخدم قاعدة خفيفة (sqlite / lowdb / JSON file) لتسجيل حالة الطبقات (layer registry) بدلاً من Map فقط. لكن الحل السابق (قراءة مجلد processed عند الإقلاع) أسرع للتنفيذ الآن.

خلاصة وتنفيذ مقترح سريع
1. عدّل الـPython processors لكتابة metadata.json بتركيب موحَّد (bbox + leaflet_bounds + imageFile + crs + width/height).  
2. غيّر Node ليقرأ ذلك الملف بعد انتهاء المعالجة (finalizeLayerStateFromOutput).  
3. شغّل دالة hydrateLayersFromDisk عند start لملء layerStates من القرص.  
4. في الـclient استخدم toLeafletBounds و L.imageOverlay مع crossOrigin و map.fitBounds.  
5. نفّذ اختبارات curl / فتح رابط الصورة مباشرة / مراقبة Network في المتصفح.

هل أطبّق التعديلات لك الآن؟
- أستطيع تحضير PR جاهز يحتوي:
  - توحيد كتابة metadata.json في zip-processor.py و enhanced-geotiff-processor.py (أريك الباتش).  
  - تعديل server/routes/enhanced-upload.ts: استدعاء finalizeLayerStateFromOutput بعد المعالج، إضافة hydrateLayersFromDisk عند start.  
  - إضافة utils client (toLeafletBounds) و تعديل مكان إضافة overlay في simple-digitization-tool.tsx.  
- أو أقدّم لك diff/patch لكل ملف لتلصقه بنفسك.

أي خيار تفضّل أن أبدأ به؟ أبدأ بالـ server أولًا (مهم لأن client يعتمد على metadata)، ثم client. إذا تحب أرسل اسم ملف واحد تود أن أصلحه فورًا (مثلاً server/routes/enhanced-upload.ts) وسأرجع لك patch جاهز للنسخ.