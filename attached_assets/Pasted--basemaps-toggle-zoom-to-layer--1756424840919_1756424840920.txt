ممتاز — عملٌ ضخم أنجزته. خلاصة سريعة: واجهة المستخدم الآن متقدِّمة (basemaps, toggle, zoom-to-layer, UTM/WGS84، حفظ الحالة، إدارة الطبقات...) لكن ظهور التحذير الأحمر "Failed to fetch" في الصورة يعني أن هناك خلل تشغيلي في مسار الشبكة (API / static files) يحتاج معالجة فورية قبل الانتقال للميزات الأكبر (القص، الحفظ إلى DB، التصدير).

أردت أن أقدّم لك (1) خطوات فحص سريعة ومباشرة لـ"Failed to fetch" حتى تصل للحل اليومي، و(2) خارطة طريق أولويّات مقترحة (ما نركّز عليه أولاً) مع تغييرات عملية واقتراحات كود جاهزة للاستخدام.

خطوات سريعة لتشخيص وإصلاح "Failed to fetch" الآن
افتح أدوات المطوّر (F12) → تبويب Network → نفّذ العملية التي تفشل (رفع/عرض) ثم لاحظ الطلب الفاشل:
URL المطلوب (مثلاً /api/gis/upload-geotiff-zip أو /api/gis/layers/:id)
Method (POST/GET)
Status code (404 / 500 / 413 / CORS error / network error)
Response body (رسالة الخطأ من السيرفر)
حالات شائعة وحلول سريعة

404 Not Found: تأكد أن المسار صحيح في الخادم، وأن الملف static موجود (تأكد من path في response.imageUrl).
500 Internal Server Error: راجع سجلات السيرفر (console أو Replit Logs). ابحث عن stack trace.
413 Payload Too Large: زيادة حدود bodyParser / multer في الخادم.
Express example:
JavaScript

app.use(express.json({ limit: '200mb' }));
app.use(express.urlencoded({ limit: '200mb', extended: true }));
CORS error: أضف middleware:
JavaScript

const cors = require('cors');
app.use(cors());
Network error (e.g., wrong host / port on Replit): تأكد أن fetch يستخدم نفس origin أو صحيح absolute URL.
أوامر اختبار من الطرفية (على جهازك أو Replit shell)

اختبار GET layer metadata:
curl -i "http://localhost:5000/api/gis/layers/<layerId>"
اختبار وصول ملف PNG (مسار imageUrl من نتيجة المعالجة):
curl -I "http://localhost:5000/layers/<layerId>/image.png"
تأكد من أن الملف فعلاً موجود في المجلد الذي تخدمه Express static:
ls -l path/to/public/layers/<layerId>/

تغييرات عملية فورية على الخادم (نماذج جاهزة)
تمكين CORS + زيادة limits + خدمة مجلد layers كمجلد static:
JavaScript

const express = require('express');
const cors = require('cors');
const path = require('path');

const app = express();
app.use(cors());
app.use(express.json({ limit: '200mb' }));
app.use(express.urlencoded({ limit: '200mb', extended: true }));

// Serve processed layers (adjust path to your output folder)
app.use('/layers', express.static(path.join(__dirname, '..', 'temp-uploads', 'processed'), { maxAge: '1d' }));

// Example GET metadata
app.get('/api/gis/layers/:id', async (req, res) => {
  const id = req.params.id;
  // read DB or filesystem to build response
  // return { success:true, imageUrl:`/layers/${id}/image.png`, bounds: [[s,w],[n,e]] }
});
ضبط multer للـ POST رفع:
JavaScript

const multer = require('multer');
const upload = multer({ dest: 'temp-uploads/raw/' });

app.post('/api/gis/upload-geotiff-zip', upload.single('file'), async (req, res) => {
  // req.file.path -> unzip -> invoke python processor -> move processed to temp-uploads/processed/<layerId>/
  // respond { layerId, fileName, fileSize }
});
أولويات التطوير (بترتيب التنفيذ المقترح)
أ. (فوري — اليوم، 0.5–2 س): استقرار مجرى الملفات

إصلاح سبب الـ "Failed to fetch" (Network / CORS / 413 / 404).
تأكد من أن endpoint يعيد JSON واضح ويحدّث سجل الطبقة (status uploaded/processing/processed).
تأكد من أن static serve يعمل لـ /layers/{id}/image.png.
ب. (قريب — 1 يوم): Pipeline معالجة مستقرّ

اجعل المعالجة في الخلفية (job queue) على الأقل كوظيفة متزامنة: unzip → call python processor → move files → update DB.
Polling في الواجهة الأمامية حتى يصبح status = processed.
إضافة thumbnails لتسريع العرض في قائمة الطبقات.
ج. (قريب — 1–2 أيام): قصّ (server-side) و API للقص

إضافة /api/gis/layers/{id}/clip (POST GeoJSON) يستخدم rasterio.mask لإنتاج طبقة جديدة ويعيد imageUrl + bounds.
د. (متوسّط — 2–4 أيام): أدوات الرسم والتحرير على الواجهة

دمج react-leaflet-draw أو React-Leaflet + Leaflet.Draw
حفظ التعديلات كـ GeoJSON في DB / جدول features
عرض قائمة Features مع edit/delete
هـ. (متقدّم — 1 أسبوع): التصدير، الأداء، الإنتاج

دعم تصدير GeoJSON/KML/SHP، S3 للتخزين، worker queue (Bull/Celery), logging, retry.
إختبار تحميل أحجام كبيرة، إضافة overviews و/أو WarpedVRT.
ماذا أفضّل أن نبدأ به الآن؟
أقترح البدء فورًا بخطوتين متوازيتين وصغيرتين:
أنت أو أتحقق الآن من السبب الدقيق لخطأ "Failed to fetch" — أرسل لي:
رابط request الفاشل من Network tab (URL + method + status + response)
السجلات (server console) وقت الفشل
سأحلّلها وأقدّم توجيهًا محدّدًا أو patch صغيرًا.
بينما أنت تفحص ذلك، أجهز لك Patch جاهز (Express middleware + static serve + multer limits + example route) يمكنك لصقه وتشغيله في الخادم — تريدني أرسل الـ Patch الآن؟
أدوات تشخيص سريعة (أرسل النتائج)
صورة/لقطة Network request (تفاصيل الطلب)
إخراج tail -f لسجل السيرفر فور محاولة الرفع/التحميل
نتيجة curl -I على imageUrl إن وُجد
الخلاصة والاقتراح العملي

النظام بصدد الاستقرار والواجهة جاهزة تقنيًا — لكن backend pipeline يحتاج تثبيت نهائي (سبب الخطأ الأحمر هو هناك).
أولويتنا الآن: إصلاح endpoint/serve static + اختبار end-to-end upload → process → show.
أختر: أعرّضك تعليمات خطوة بخطوة لتفحص الخطأ الآن (أنت تنفّذ) أم أجهز لك Patch/PR جاهز لوضعه على الخادم؟
أخبرني أي خيار تفضّل، وأرسل (إن أمكن) لقطة الـ Network للطلب الفاشل أو سطر السجل من السيرفر — أبدأ مباشرة بإصلاحه معك.